{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\ude80 Very FAST \ud83d\ude80 PHP AutoMapper with on the fly code generation","text":""},{"location":"#presentation","title":"Presentation","text":"<p>Welcome to the AutoMapper documentation, this library solves a simple problem: removing all the code you need to map one object to another. A boring code to write and often replaced by less-performant alternatives.</p> <p>AutoMapper uses a convention-based matching algorithm to match up source to destination values. AutoMapper is geared towards model projection scenarios to flatten complex object models to DTOs and other simple objects, whose design is better suited for serialization, communication, messaging, or simply an anti-corruption layer between the domain and application layer.</p>"},{"location":"#usage","title":"Usage \ud83d\udd79\ufe0f","text":"<p>Here is the quickest way to use AutoMapper:</p> <pre><code>use AutoMapper\\AutoMapper;\n\n$automapper = AutoMapper::create();\n\n$source = new Source();\n$target = $automapper-&gt;map($source, Target::class);</code></pre> <p>That's it! <code>AutoMapper</code> will find the best way to map from <code>$source</code> object to a new <code>Target</code> object. It will also generate a PHP class that will do the mapping for you and serve as a cache for future mapping.</p> <p>Of course there are many ways to customize the mapping, this documentation will explain all of them.</p>"},{"location":"#installation","title":"Installation \ud83d\udce6","text":"<pre><code>composer require jolicode/automapper</code></pre>"},{"location":"#serializer","title":"Serializer","text":"<p>There is more than object to object mapping with AutoMapper. You can also map to or from generic data structure like <code>array</code> or <code>stdClass</code>. When you map to an <code>array</code>, AutoMapper will try its best to only use scalar values, so you can serialize the result to JSON or XML.</p>"},{"location":"#why-should-i-use-it","title":"Why should I use it ? \ud83d\ude4b","text":"<p>The real question may be \u201cwhy use object-object mapping?\u201d Mapping can occur in many places in an application, but mostly in the boundaries between layers, such as between the UI/Domain layers, or Service/Domain layers. Concerns of one layer often conflict with concerns in another, so object-object mapping leads to segregated models, where concerns for each layer can affect only types in that layer.</p>"},{"location":"#further-reading","title":"Further reading \ud83d\udcda","text":"<ul> <li>Getting Started</li> <li>How to customize the mapping?</li> <li>Using the Symfony Bundle</li> </ul>"},{"location":"_nav/","title":"nav","text":"<ul> <li>Home</li> <li>Getting started<ul> <li>Understanding the <code>source</code> and <code>target</code></li> <li>Using the context</li> <li>Configuration</li> <li>Cache</li> </ul> </li> <li>Mapping<ul> <li>MapTo and MapFrom attributes</li> <li>Symfony Serializer</li> <li>Ignoring properties</li> <li>Conditional mapping</li> <li>Groups</li> <li>Transformer</li> <li>Provider</li> <li>Mapping inheritance</li> <li>DateTime format</li> </ul> </li> <li>Symfony Bundle<ul> <li>Installation</li> <li>Configuration</li> <li>Cache Warmup</li> <li>Expression Language</li> <li>Api Platform</li> <li>Migrate existing application</li> <li>Debugging</li> </ul> </li> <li>Upgrading to 9.0</li> <li>Contributing</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#releasing","title":"Releasing","text":"<p>Whenever you're doing a release you need to do some updates in order for the project to keep history on what was done and some other stuff.</p>"},{"location":"contributing/#changelog","title":"Changelog","text":"<p>First you'll need to update the CHANGELOG file (<code>./CHANGELOG.md</code>), take everything under the <code>Unreleased</code> section and create a new section for your new tag with the today's date.</p>"},{"location":"contributing/#version","title":"Version","text":"<p>When a new version is tagged, you have to update the version constants within the <code>AutoMapper/AutoMapper</code> so  transformers can be updated with last AutoMapper version.</p>"},{"location":"upgrading-9.0/","title":"Upgrading from 8.x to 9.0","text":"<p>9.0 is major release of AutoMapper. It brings a lot of new features and improvements. We recommend first to check  the new documentation to see if the new features are useful for your project.</p> <p>If you upgrade from 8.x to 9.0, you will need to make some changes to your code, but most of existing behavior should still work.</p>"},{"location":"upgrading-9.0/#bundle","title":"Bundle","text":"<p>If you use the bundle, it is now integrated in the main package. You can remove the <code>jolicode/automapper-bundle</code> package from your <code>composer.json</code> file.</p> <p>Then you have to use the new namespace for the bundle:</p> <pre><code>use AutoMapper\\Symfony\\Bundle\\AutoMapperBundle;</code></pre> <p>You will also need to update the bundle configuration, see the bundle documentation for more information.</p>"},{"location":"upgrading-9.0/#custom-transformers","title":"Custom Transformers","text":"<p>The <code>CustomPropertyTransformerInterface</code> and <code>CustomModelTransformerInterface</code> have been removed in favor of the  <code>PropertyTransformerInterface</code> interface handling both case.</p> <p>See the transformers documentation for more information.</p>"},{"location":"bundle/","title":"Symfony Bundle","text":"<p>To make Symfony's users life easier, we made a bundle that will make all DependencyInjection for you and offer extra  features linked to Symfony way of doing things.</p> <ul> <li>Installation</li> <li>Configuration</li> <li>Cache Warmup</li> <li>Expression Language</li> <li>Api Platform</li> <li>Migrate existing application</li> <li>Debugging</li> </ul>"},{"location":"bundle/api-platform/","title":"Api Platform integration","text":"<p>Warning</p> <p>The api platform integration is in a experimental state, and may change in the future. Some behavior may not be handled correctly, and some features may not be implemented.</p> <p>If you find a bug or missing feature, please report it on the issue tracker.</p> <p>This bundle provides a way to integrate with Api Platform by generating the mappers for you.</p> <p>It injects extra data in the mappers when we map a Resource class to or from an array.</p> <p>You have to enable the <code>api_platform</code> option in the configuration to use this feature.</p> <p>If you have custom normalizer with some logic inside you will have to convert this logic with our library way of doing things. See our migrate guide for more information.</p>"},{"location":"bundle/cache-warmup/","title":"Caching class for production","text":"<p>Instead of caching metadata of a class, AutoMapper generates a class in PHP that remove all reflection calls and the overhead of the decision process. This class is generated in the cache directory of your Symfony application.</p> <p>In order to do that it needs to know which mapping you want to generate. By default, it will generate the mapper when asked for the first time.</p> <p>This may not be suited in a production environment, as it may slow down the first request or the disk may not be  writable resulting in an error.</p> <p>To avoid this problem, you can specify the mappings you want to generate in the configuration file : </p> <pre><code>automapper:\n  mapping:\n    mappers:\n      - source: App\\Entity\\User\n        target: App\\Api\\DTO\\User\n\n      - source: App\\Entity\\User\n        target: array\n        reverse: true</code></pre> <p>Then when running the <code>cache:warmup</code> command, this will generate the mappers for you.</p> <p>Note</p> <p>When a mapping have dependencies, it will generate the dependencies as well even if not specified in the mappings configuration.</p> <p>This way, you can generate all the mappers you need before deploying your application.</p>"},{"location":"bundle/cache-warmup/#automatically-register-mappers","title":"Automatically register mappers","text":"<p>You can also define a list of paths where the mappers are located, and the bundle will automatically register them for you.</p> <pre><code>automapper:\n  mapping:\n    paths:\n      - \"%kernel.project_dir%/src/Entity\"</code></pre> <p>All classes in the specified paths with the <code>#[Mapper]</code> attribute will be registered in the container.</p> <p>This attribute need a <code>source</code> and/or <code>target</code> argument to specify which mapping to register.</p> <pre><code>#[Mapper(source: 'array', target: 'array')]\nclass Entity\n{\n    public string $foo;\n}</code></pre> <p>This will generate a mapper from <code>array</code> to <code>Entity</code> and vice versa during the cache warmup.</p> <p>You can also specify an array of sources and / or targets to generate multiple mappers at once.</p> <pre><code>#[Mapper(source: 'array', target: ['array', EntityDto::class])]\nclass Entity\n{\n    public string $foo;\n}</code></pre>"},{"location":"bundle/configuration/","title":"Configuring the Bundle","text":"<p>By default the bundle is configured to work out of the box, but you can customize it to your needs.</p> <p>Create a configuration file in your Symfony application, for example <code>config/packages/automapper.yaml</code>.</p> <p>Then configure the bundle to your needs, for example:</p> <pre><code>automapper:\n  class_prefix: \"Symfony_Mapper_\"\n  constructor_strategy: 'auto'\n  date_time_format: !php/const:DateTimeInterface::RFC3339\n  check_attributes: true\n  auto_register: true\n  map_private_properties: true\n  allow_readonly_target_to_populate: false\n  normalizer:\n    enabled: false\n    only_registered_mapping: false\n    priority: 1000\n  loader:\n    eval: false\n    cache_dir: \"%kernel.cache_dir%/automapper\"\n    reload_strategy: \"always\"\n  serializer_attributes: true\n  api_platform: false\n  name_converter: null\n  mapping:\n    paths:\n      - \"%kernel.project_dir%/src/Entity\"\n    mappers:\n      - source: AutoMapper\\Bundle\\Tests\\Fixtures\\User\n        target: AutoMapper\\Bundle\\Tests\\Fixtures\\UserDTO\n        reverse: false</code></pre>"},{"location":"bundle/configuration/#configuration-reference","title":"Configuration Reference","text":"<ul> <li><code>class_prefix</code> (default: <code>Symfony_Mapper_</code>): The prefix to use for the generated mappers class names;</li> <li> <p><code>constructor_strategy</code> (default: <code>auto</code>): If the generated mapper should use the constructor to instantiate the target. </p> <ul> <li>When set to <code>auto</code>, AutoMapper will use the constructor if all mandatory properties are present in the source object,    otherwise it will not use it.</li> <li>When set to <code>never</code>, AutoMapper will never use the constructor.</li> <li>When set to <code>always</code>, AutoMapper will always use the constructor, even if some mandatory properties are missing.    In this case you may need to provide a default value for the missing properties using the context.</li> </ul> </li> <li> <p><code>date_time_format</code> (default: <code>\\DateTimeInterface::RFC3339</code>): The format to use to transform a date from/to a string,   can be overwritten by the attributes thanks to <code>dateTimeFormat</code> property, see DateTime format   for more details about it;</p> </li> <li><code>check_attributes</code> (default: <code>true</code>): Check if the field should be mapped at runtime, this allow you to have dynamic   partial mapping, if you don't use this feature set it to false as it will improve the performance;</li> <li><code>auto_register</code> (default: <code>true</code>): If the bundle should auto register the mappers in the container when it does not   exist, when set to <code>false</code> you have to register the mappers manually using the <code>mapping</code> option, this option is useful   when you cannot write to the disk, and you want to use the cache warmup;</li> <li><code>map_private_properties</code> (default: <code>true</code>): If the mapper should map private properties;</li> <li><code>allow_readonly_target_to_populate</code> (default: <code>false</code>): Will throw an exception if you use a readonly class as target   to populate if set to <code>false</code>.</li> <li><code>normalizer</code>:  Configure how the normalizer should behave;<ul> <li><code>enabled</code> (default: <code>false</code>): If the normalizer should be enabled;</li> <li><code>only_registered_mapping</code> (default: <code>false</code>): If the normalizer should only use the registered mapping;</li> <li><code>priority</code> (default: <code>1000</code>): The priority of the normalizer, the higher the value the higher the priority;</li> </ul> </li> <li><code>loader</code>:<ul> <li><code>eval</code> (default: <code>false</code>): If the loader should use the eval function to load the mappers, this is useful when   you cannot write to the disk;</li> <li><code>cache_dir</code> (default: <code>%kernel.cache_dir%/automapper</code>): The directory where the loader should write the mappers;</li> <li><code>reload_strategy</code> (default: <code>always</code> when <code>%kernel.debug%</code> is true, <code>never</code> otherwise): The strategy to use to    generate the mappers between each request, can be <code>always</code>, <code>never</code> or <code>on_change</code>:<ul> <li><code>always</code> will generate the mappers at each request;</li> <li><code>never</code> will generate them only if they don't exist;</li> <li><code>on_change</code> will generate the mappers only if the source or target class has changed since the last generation;</li> </ul> </li> </ul> </li> <li><code>serializer_attributes</code> (default: <code>true</code> if the symfony/serializer is available, false otherwise): A boolean which  indicate if we use the attribute of the symfony/serializer during the mapping, this only apply to the <code>#[Groups]</code>,  <code>#[MaxDepth]</code>, <code>#[Ignore]</code> and <code>#[DiscriminatorMap]</code> attributes;</li> <li><code>api_platform</code> (default: <code>false</code>): A boolean which indicate if we use services from the api-platform/core package and inject extra data (json ld) in the mappers when we map a Resource class to or from an array.</li> <li><code>name_converter</code> (default: <code>null</code>): A service id which implement the <code>AdvancedNameConverterInterface</code> or    <code>NameConverterInterface</code> (starting from 7.2) from the symfony/serializer, this name converter will be used when     mapping from an array to an object and vice versa;</li> <li><code>mapping</code>: Allow to auto register the mappers for warmup, and selecting them to normalizer if wanted<ul> <li><code>paths</code>: A list of paths where to look for mappers to register; This will automatically register all classes   with the <code>#[Mapper]</code> attribute in the given paths.</li> <li><code>mappers</code>: A list of mapping to register, each mapping should have a <code>source</code> and a <code>target</code> key, and can have   a <code>reverse</code> key to also register the reverse mapping. </li> </ul> </li> </ul>"},{"location":"bundle/debugging/","title":"Debug a Mapper","text":"<p>AutoMapper provides 2 ways to debug what's going on with a mapper when using the Symfony bundle:</p>"},{"location":"bundle/debugging/#the-debugmapper-command","title":"The <code>debug:mapper</code> Command","text":"<p>The <code>debug:mapper</code> command will display the mapping information for a specific mapper.  This can be useful to understand how AutoMapper is mapping your objects and why some properties are not mapped.</p> <pre><code>php bin/console debug:mapper User UserDTO</code></pre> <p></p>"},{"location":"bundle/debugging/#using-the-symfony-profiler","title":"Using the symfony profiler","text":"<p>AutoMapper provides a panel in the Symfony profiler that will display the mapping information for each request.  Please note that this only display Mapper that has been generated during the request, if you have a mapper that was not generated during the request it will not be displayed.</p> <p>You can find the panel in the Symfony profiler under the <code>AutoMapper</code> tab.</p> <p> </p>"},{"location":"bundle/expression-language/","title":"Expression Language","text":"<p>AutoMapper allow you to use the Symfony Expression Language in some places to make your mapping more flexible.</p> <p>When using the Bundle, it add severals function that you can use in the expression language.</p>"},{"location":"bundle/expression-language/#env","title":"env","text":"<p>The <code>env</code> function allow you to access the environment variables.</p> <pre><code>class Entity\n{\n    #[MapTo('array', if: \"env('FEATURE_ENABLED')\")]\n    public string $name;\n}</code></pre>"},{"location":"bundle/expression-language/#service","title":"service","text":"<p>The <code>service</code> function allow you to call a service from the container.</p> <p>First, add the <code>#[AsAutoMapperExpressionService]</code> attribute to your service.</p> <pre><code>namespace App\\Service;\n\nuse AutoMapper\\Symfony\\Attribute\\AsAutoMapperExpressionService;\n\n#[AsAutoMapperExpressionService(alias: 'my_service')\nclass MyService\n{\n    public function transform(Entity $entity): string\n    {\n        return 'transformed';\n    }\n\n    public function check(): bool\n    {\n        return false;\n    }\n}</code></pre> <p>Then, use the <code>service()</code> function to refer that service inside your expression.</p> <pre><code>class Entity\n{\n    #[MapTo(transformer: \"service('my_service').transform(source)\")]\n    public string $name;\n\n    // Or without an alias\n    #[MapTo(transformer: \"service('App\\\\\\Service\\\\\\MyService').transform(source)\")]\n    public string $name;\n\n    #[MapTo(if: \"service('my_service').check()\")]\n    public int $age;\n}</code></pre>"},{"location":"bundle/installation/","title":"Installing the Symfony Bundle","text":"<p>The bundle is already available on the <code>jolicode/automapper</code> package, you don't need to add any packages to your composer.json file.</p>"},{"location":"bundle/installation/#registering-the-bundle","title":"Registering the bundle","text":"<p>To use it, you have to register the main bundle class in your <code>config/bundles.php</code> file.</p> <pre><code>return [\n    // ...\n    AutoMapper\\Symfony\\Bundle\\AutoMapperBundle::class =&gt; ['all' =&gt; true],\n];</code></pre>"},{"location":"bundle/installation/#usage","title":"Usage","text":"<p>Once the bundle is registered, you can use the <code>AutoMapperInterface</code> service to map your objects.</p> <pre><code>use AutoMapper\\AutoMapperInterface;\n\nclass MyController\n{\n    public function __construct(private AutoMapperInterface $autoMapper)\n    {\n    }\n\n    #[Route('/my-route', name: 'my_route')]\n    public function index()\n    {\n        $source = new Source();\n        $target = $this-&gt;autoMapper-&gt;map($source, 'array');\n\n        return new JsonResponse($target);\n    }\n}</code></pre>"},{"location":"bundle/migrate/","title":"Migrate an existing application","text":"<p>If you have an existing application with custom normalizers, you may not want to rewrite everything at the same time.</p> <p>This library provide a way to migrate your existing normalizers with our convention step by step without breaking  your application.</p> <p>This can be done by using the <code>only_registered_mapping</code> option in the <code>normalizer</code> configuration.</p> <pre><code># config/packages/automapper.yaml\nautomapper:\n    normalizer:\n        enabled: true\n        only_registered_mapping: true</code></pre> <p>Once this option is enabled, only the normalizers that are registered in the <code>mappings</code> configuration will be used. Others will be ignored and use existing normalizers.</p> <p>This way, you can migrate your application step by step.</p>"},{"location":"bundle/migrate/#selecting-a-normalizer-to-migrate","title":"Selecting a normalizer to migrate","text":"<p>You can first select a class that don't have custom normalizer logic to migrate. This way you can ensure than the  default behavior of the library is working the same as the <code>symfony/serializer</code> component.</p> <p>You need to register this class in the <code>mappings</code> configuration.</p> <pre><code># config/packages/automapper.yaml\nautomapper:\n    normalizer:\n        enabled: true\n        only_registered_mapping: true\n    mappings:\n        mappers:\n            - { source: App\\Entity\\MyEntity, target: 'array' }</code></pre> <p>If you want to migrate the denormalizer, you can use the <code>reverse</code> option to register the reverse mapping.</p> <pre><code># config/packages/automapper.yaml\nautomapper:\n    normalizer:\n        enabled: true\n        only_registered_mapping: true\n    mappings:\n        mappers:\n            - { source: App\\Entity\\MyEntity, target: 'array', reverse: true }</code></pre> <p>Warning</p> <p>If this entity have sub objects, they will also use our library we you normalize from the <code>App\\Entity\\MyEntity</code> class. If you normalize only the sub object it will still use the existing normalizer.</p>"},{"location":"bundle/migrate/#serializer-attributes","title":"Serializer attributes","text":"<p>If you have serializer attributes on your entity, you can also enabled the <code>serializer_attributes</code> option to use them.</p> <pre><code># config/packages/automapper.yaml\nautomapper:\n    normalizer:\n        enabled: true\n        only_registered_mapping: true\n    serializer: true\n    mappings:\n        mappers:\n            - { source: App\\Entity\\MyEntity, target: 'array' }</code></pre>"},{"location":"bundle/migrate/#migrating-a-custom-normalizer","title":"Migrating a custom normalizer","text":"<p>If you have a custom normalizer with some logic inside you will have to convert this logic with our library way of doing things.</p> <p>For example, if you have a custom normalizer that add a <code>virtualProperty</code> the normalized array, you can use a tansformer to do the same thing.</p> <pre><code>#[MapTo('array', property: 'virtualProperty', transformer: MyTransformer::class)]\nclass App\\Entity\\MyEntity\n{\n    // ...\n}</code></pre> <p>See the transformer documentation for more information on how to achieve that.</p> <p>Most custom normalizer only need transformers or <code>#[MapTo]</code> / <code>#[MapFrom]</code> to be converted.</p> <p>If you have custom logic that may not be converted using our library, please open an issue on the github repository with your use case so we can help you convert it.</p>"},{"location":"getting-started/","title":"Getting started","text":"<ul> <li>Understanding the <code>source</code> and <code>target</code></li> <li>Using the context</li> <li>Configuration</li> <li>Cache</li> </ul>"},{"location":"getting-started/cache/","title":"Cache","text":"<p>AutoMapper can uses a cache system to store each Mapper generated for a specific <code>source</code> and <code>target</code> class.  This way, the Mapper is generated only once and reused for each mapping.</p> <p>By default, it will evaluate the generated Mapper, new call inside the same request or cli command will not regenerate the Mapper.</p> <p>However, next request or cli command will regenerate the Mapper.</p> <p>To avoid regenerating the Mapper, you can use the <code>cacheDirectory</code> option in the <code>AutoMapper::create()</code> method.</p> <pre><code>use AutoMapper\\AutoMapper;\n\n$autoMapper = AutoMapper::create(cacheDirectory: '/path/to/cache');</code></pre> <p>This way, the Mapper will be stored in the <code>/path/to/cache</code> directory and reused for each mapping. However, if you change the <code>source</code> or <code>target</code> class, the Mapper will be regenerated.</p> <p>Warning</p> <p>Some changes may not be detected by the cache system, like changing a dependency used by the source or target class. You may need to clean it manually.</p> <p>However, we try our best to detect those changes, if you encounter a problem, please open an issue on the GitHub repository.</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>AutoMapper ships with a default configuration that should work out of the box. However, you can customize it to your needs.</p> <p>You need to create a <code>Configuration</code> object and pass it to the <code>AutoMapper::create()</code> method.</p> <pre><code>use AutoMapper\\Configuration;\nuse AutoMapper\\AutoMapper;\n\n$configuration = new Configuration(\n    classPrefix: 'Mapper_'\n    constructorStrategy: 'auto',\n    dateTimeFormat: \\DateTimeInterface::RFC3339,\n    attributesChecking: true,\n    autoRegister: true,\n    mapPrivateProperties: true,\n    allowReadonlyTargetToPopulate: false,\n);\n$autoMapper = AutoMapper::create(configuration: $configuration);</code></pre> <p>The <code>Configuration</code> object allows you to define the following options:</p> <ul> <li><code>classPrefix</code> (default: <code>AutoMapper_</code>)</li> </ul> <p>The prefix to use for the generated mappers class names. It can be useful to change it you have a different AutoMapper  instance in your application and they should not conflict when mapping the same classes.</p> <ul> <li><code>constructorStrategy</code> (default: <code>auto</code>)</li> </ul> <p>If the generated mapper should use the constructor to instantiate the target. When set to auto, AutoMapper will use the constructor if all mandatory properties are present in the source object, otherwise it will not use it. Set it to <code>never</code> to never use the constructor. Set it to <code>always</code> to always use the constructor, even if some mandatory properties are missing. In this cas you may need to provide a default value for the missing properties using the context.</p> <ul> <li><code>dateTimeFormat</code> (default: <code>\\DateTimeInterface::RFC3339</code>)</li> </ul> <p>The format to use to transform a date from/to a string. It may be useful if all your dates are in a specific format and  you want to avoid repeating the format in all your mappings.</p> <ul> <li><code>attributesChecking</code> (default: <code>true</code>)</li> </ul> <p>Setting this to false will not generate the code to check for <code>allowed_attributes</code> and <code>ignored_attributes</code> at runtime.  Some applications may not need this feature and disabling it will improve the performance as it avoid a check for each  property at runtime.</p> <ul> <li><code>autoRegister</code> (default: <code>true</code>)</li> </ul> <p>AutoMapper generate the mappers on the fly when they are needed, also it store them in a cache directory. On the next run it will try to fetch the mapper from the cache directory.</p> <p>Caching on the fly may slow down the first request or the disk may not be writable resulting in an error in some environments.</p> <p>Setting this to false will make the <code>AutoMapper</code> throw an exception if the mapper is not found in the cache directory.</p> <p>This can be useful if you want to pre generate all the mappers and have tests to ensure that all the mappers are generated.</p>"},{"location":"getting-started/context/","title":"Mapping Context","text":"<p>When using the <code>map</code> method, you can pass a <code>context</code> as the third argument. This <code>context</code> can be used to change  the behavior of the mapping process.</p> <pre><code>$source = new User();\n$target = $autoMapper-&gt;map($source, UserDTO::class, ['key' =&gt; 'value']);</code></pre>"},{"location":"getting-started/context/#groups","title":"Groups","text":"<p>Groups allow you to define a subset of properties that should be mapped.</p> <pre><code>$source = new User();\n$target = $autoMapper-&gt;map($source, UserDTO::class, ['groups' =&gt; ['read']]);</code></pre> <p>In this case only properties that have been flagged with the <code>read</code> group will be mapped.</p> <p>Warning</p> <p>Groups are checked on both the source and target objects, both must have one of the groups from the context to be mapped.</p>"},{"location":"getting-started/context/#allowed-attributes","title":"Allowed attributes","text":"<p>Allowed attributes allow you to define a subset of properties that should be mapped. This is the same as groups but it does need to be defined on the source or target object.</p> <pre><code>$source = new User();\n$target = $autoMapper-&gt;map($source, UserDTO::class, [\n    'allowed_attributes' =&gt; ['id']\n]);</code></pre> <p>In this case only the <code>id</code> property will be mapped.</p> <p>Warning</p> <p>The mapper will only check the allowed attributes from the property name of the source object and not the target object.</p> <p>You can also provide a nested array to allow only specific attributes of nested objects.</p> <pre><code>$source = new User();\n$source-&gt;address = new Address();\n$target = $autoMapper-&gt;map($source, UserDTO::class, [\n    'allowed_attributes' =&gt; ['address' =&gt; ['city']]\n]);</code></pre> <p>In this case only the <code>city</code> property of the <code>address</code> object will be mapped.</p>"},{"location":"getting-started/context/#ignored-attributes","title":"Ignored attributes","text":"<p>Ignored attributes is the opposite of allowed attributes, it allows you to define a subset of properties  that should not be mapped.</p> <pre><code>$source = new User();\n$target = $autoMapper-&gt;map($source, UserDTO::class, [\n    'ignored_attributes' =&gt; ['id']\n]);</code></pre> <p>In this case all properties except the <code>id</code> property will be mapped.</p>"},{"location":"getting-started/context/#circular-references","title":"Circular references","text":"<p>You may have circular references in your objects i.e. an object references itself. AutoMapper by default will keep track of the objects it has already mapped to avoid infinite loops and conserve circular references in the target object.</p> <pre><code>$source = new User();\n$source-&gt;friend = $source;\n$target = $autoMapper-&gt;map($source, UserDTO::class);\n\nassert($target-&gt;friend === $target); // true</code></pre> <p>Sometimes you may want to break the circular reference, you can do this by passing the <code>circular_reference_limit</code> option.</p> <pre><code>$source = new User();\n$source-&gt;friend = $source;\n$target = $autoMapper-&gt;map($source, UserDTO::class, ['circular_reference_limit' =&gt; 0]);</code></pre> <p>In this case a <code>CircularReferenceException</code> will be thrown.</p> <p>You can also specify a callback to handle the circular reference.</p> <pre><code>$source = new User();\n$source-&gt;friend = $source;\n$target = $autoMapper-&gt;map($source, UserDTO::class, [\n    'circular_reference_handler' =&gt; function ($source, $context) {\n        return null;\n    }\n]);</code></pre> <p>In this case the <code>friend</code> property will be set to <code>null</code>.</p>"},{"location":"getting-started/context/#skip-null-values","title":"Skip null values","text":"<p>In some case having a null value may precise that the value should not be mapped and the target should keep its value.</p> <p>You can enable this behavior by passing the <code>skip_null_values</code> option.</p> <pre><code>$source = new User();\n$source-&gt;name = null;\n$target = new UserDTO();\n$target-&gt;name = 'Jane';\n$target = $autoMapper-&gt;map($source, $target, ['skip_null_values' =&gt; true]);\n\nassert($target-&gt;name === 'Jane'); // true</code></pre>"},{"location":"getting-started/context/#skip-uninitialized-values","title":"Skip uninitialized values","text":"<p>Like for null values and <code>skip_null_values</code>, in some case having an uninitialized value may precise that the value should not be mapped and the target should keep its value.</p> <p>You can enable this behavior by passing the <code>skip_uninitialized_values</code> option.</p> <pre><code>class User\n{\n    public string $name;\n}\n\n$source = new User(); // do not initialize $name property\n$target = new UserDTO();\n$target-&gt;name = 'Jane';\n$target = $autoMapper-&gt;map($source, $target, ['skip_uninitialized_values' =&gt; true]);\n\nassert($target-&gt;name === 'Jane'); // true</code></pre>"},{"location":"getting-started/context/#date-time-format","title":"Date Time format","text":"<p>When mapping a <code>DateTimeInterface</code> object to a string, AutoMapper will format the date, you can change the format by passing the <code>date_time_format</code> option.</p> <pre><code>$source = new User();\n$source-&gt;createdAt = new DateTime('2021-01-01');\n$target = $autoMapper-&gt;map($source, UserDTO::class, ['date_time_format' =&gt; 'Y-m-d']);</code></pre> <p>In this case the <code>createdAt</code> property will be mapped to the string <code>2021-01-01</code>.</p> <p>By default AutoMapper uses the <code>DateTimeInterface::RFC3339</code> format.</p>"},{"location":"getting-started/context/#map-to-accessor-parameter","title":"Map to accessor parameter","text":"<p>When mapping from an object, AutoMapper will use the best available method or property to fetch the value of the property. Sometimes this method may have parameters, you can specify those parameters by passing the <code>map_to_accessor_parameter</code> option.</p> <p>You will also have to link the parameter of the method to the context by using the <code>MapToContext</code> attribute.</p> <pre><code>class User {\n    public function __construct(private string $name) {}\n\n    public function getName(#[MapToContext('suffix')] string $suffix): string {\n        return $this-&gt;name . $suffix;\n    }\n}\n\n$source = new User(name: 'Jane');\n$target = $autoMapper-&gt;map($source, UserDTO::class, [\n    'map_to_accessor_parameter' =&gt; ['suffix' =&gt; ' Doe']\n]);</code></pre>"},{"location":"getting-started/context/#constructor-arguments","title":"Constructor arguments","text":"<p>When mapping to an object, AutoMapper will try to use the constructor to instantiate the object. Sometimes some parameters may not be available in the source object, you can specify those parameters by passing the <code>constructor_arguments</code> option.</p> <pre><code>class UserDto {\n    public function __construct(private string $name, private \\DateTime $createdAt) {}\n}\n\n$source = new User();\n$source-&gt;name = 'Jane';\n\n$target = $autoMapper-&gt;map($source, UserDTO::class, [\n    'constructor_arguments' =&gt; [\n        UserDTO::class =&gt; ['createdAt' =&gt; new \\DateTime('2021-01-01')]\n    ]\n]);</code></pre>"},{"location":"getting-started/source-and-target/","title":"Understanding the <code>source</code> and <code>target</code>","text":"<p>The <code>source</code> and <code>target</code> are the most important concepts in AutoMapper.</p> <ul> <li>The <code>source</code> is the object or data that you want to map from.</li> <li>The <code>target</code> is the object or data that you want to map to.</li> </ul>"},{"location":"getting-started/source-and-target/#mapper-object-to-object","title":"Mapper: Object to Object","text":"<p>A Mapper happens when the <code>source</code> and <code>target</code> are both user defined class.</p> <pre><code>$source = new User();\n$target = $autoMapper-&gt;map($source, UserDTO::class);</code></pre> <p>There may be case when you want to map to an existing object.</p> <pre><code>$source = new User();\n$target = new UserDTO();\n$autoMapper-&gt;map($source, $target);</code></pre> <p>In the case the mapper will update the <code>target</code> object with the values from the <code>source</code> object.</p>"},{"location":"getting-started/source-and-target/#normalization-object-to-array","title":"Normalization : Object to Array","text":"<p>Normalization is the process of converting an <code>object</code> to an <code>array</code> with scalar values.</p> <pre><code>$source = new User();\n$target = $autoMapper-&gt;map($source, 'array');</code></pre> <p>You can also normalize to an <code>stdClass</code>.</p> <pre><code>$source = new User();\n$target = $autoMapper-&gt;map($source, \\stdClass::class);</code></pre> <p>Like the <code>map</code> method, you can also normalize to an existing array.</p> <pre><code>$source = new User();\n$target = ['id' =&gt; 1];\n$target = $autoMapper-&gt;map($source, $target);</code></pre> <p>Note</p> <p>In this case you have to assign the result of the <code>map</code> method to the <code>$target</code> variable since it is not passed by reference.</p>"},{"location":"getting-started/source-and-target/#denormalization-array-to-object","title":"Denormalization : Array to Object","text":"<p>Denormalization is the process of converting an <code>array</code> or <code>stdClass</code> to an object.</p> <pre><code>$source = ['id' =&gt; 1];\n$target = $autoMapper-&gt;map($source, User::class);</code></pre>"},{"location":"getting-started/source-and-target/#cloning","title":"Cloning","text":"<p>Clone is a special case of mapping where the <code>source</code> and <code>target</code> are the same class.</p> <pre><code>$source = new User();\n$target = $autoMapper-&gt;map($source, User::class);\n\nassert($source !== $target);</code></pre> <p>Note</p> <p>Also in this case it will do a deep clone of the <code>source</code> object, even sub-objects will be cloned and not referenced.</p>"},{"location":"mapping/","title":"Mapping","text":"<p>Despite doing its best to map objects automatically, AutoMapper provides a lot of ways to customize the mapping between a <code>source</code> and a <code>target</code>.</p> <ul> <li>MapTo and MapFrom attributes</li> <li>Symfony Serializer attributes</li> <li>Ignoring properties</li> <li>Conditional mapping</li> <li>Groups</li> <li>Transformer</li> <li>Provider</li> <li>Mapping inheritance</li> <li>DateTime format</li> </ul>"},{"location":"mapping/attributes/","title":"<code>#[MapTo]</code> and <code>#[MapFrom]</code> attributes","text":"<p>The <code>#[MapTo]</code> and <code>#[MapFrom]</code> attributes allow you to define the mapping between a property of the source and the target object.</p> <p>Respectively, the <code>#[MapTo]</code> attribute is used on a property of the <code>source</code> object, and the <code>#[MapFrom]</code> attribute  is used on a property of the <code>target</code> object.</p> <p>They both allow the same arguments, but since you can map to or from a generic data structure, they may be needed  depending on the context.</p>"},{"location":"mapping/attributes/#usage","title":"Usage","text":"<p>They can be used on :</p> <ul> <li>a public or private property (also in promoted properties)</li> </ul> <pre><code>class Entity\n{\n    #[MapTo(property: 'name')]\n    public string $title;\n}</code></pre> <ul> <li>a public or private method</li> </ul> <pre><code>class EntityDto\n{\n    private string $name;\n\n    #[MapFrom(property: 'title')]\n    public function setName($name): void\n    {\n        $this-&gt;name = $name;\n    }\n}</code></pre> <ul> <li>a class (to add virtual properties)</li> </ul> <pre><code>#[MapTo(property: 'virtualProperty')]\nclass Entity {}</code></pre>"},{"location":"mapping/attributes/#specifying-the-target-or-source","title":"Specifying the target or source","text":"<p>The <code>#[MapTo]</code> and <code>#[MapFrom]</code> attributes allow you to specify on which target or source this attribute should be applied. You can use this attribute multiple times on the same property to handle behavior for different targets or sources.</p> <pre><code>class Entity\n{\n    #[MapTo(target: EntityDto::class, property: 'name')]\n    #[MapTo(target: 'array', property: 'title')]\n    public string $title;\n}</code></pre> <pre><code>class EntityDto\n{\n    #[MapFrom(source: Entity::class, property: 'title')]\n    #[MapFrom(source: 'array', property: 'name')]\n    public string $name;\n}</code></pre> <p>You can also pass an array to the <code>target</code> or <code>source</code> argument to specify configuration for multiple targets or sources. <pre><code>class EntityDto\n{\n    #[MapFrom(source: Entity::class, property: 'title')]\n    #[MapFrom(source: 'array', property: 'name')]\n    public string $name;\n\n    #[MapFrom(source: [Entity::class, 'array'], property: 'bar')]\n    public string $foo;\n}</code></pre></p> <p>In case there is multiple attributes that match the same target (not source), you can use the <code>priority</code> argument  to specify which one should be used first. The default priority is <code>0</code>.</p> <pre><code>class Entity\n{\n    #[MapTo(ignore: true)]\n    public string $title;\n}\n\nclass EntityDto\n{\n    #[MapFrom(source: Entity::class, ignore: false, priority: 10)]\n    public string $title;\n}</code></pre>"},{"location":"mapping/attributes/#datetime-format","title":"DateTime format","text":"<p>You can override DateTime format for a property by using <code>#[MapTo]</code> or <code>#[MapFrom]</code> attributes:</p> <pre><code>#[MapTo(dateTimeFormat: \\DateTimeInterface::ATOM)]\n#[MapFrom(dateTimeFormat: \\DateTimeInterface::ATOM)]</code></pre> <p>This way, your DateTime property will be transformed to string with the corresponding format. For more details about how each DateTime format configuration works together please read the dedicated page: DateTime format.</p>"},{"location":"mapping/conditional-mapping/","title":"Conditional Mapping","text":"<p>Ignoring a property is a good way to exclude it from the mapping process, but sometimes you may want to map a property conditionally. This can be done using the <code>#[MapTo]</code> or <code>#[MapFrom]</code> attributes with the <code>if</code> argument.</p> <p>The argument may accept several types of values:</p>"},{"location":"mapping/conditional-mapping/#expression-language","title":"Expression language","text":"<p>You can use the Symfony Expression Language to define the condition. In this context the <code>source</code> object is available as <code>source</code> and the <code>context</code> array is available as <code>context</code>.</p> <pre><code>class Source\n{\n    public bool $propertyIsValid = true;\n\n    #[MapTo(if: 'source.propertyIsValid and (context[\"custom_key\"] ?? false) == true')]\n    public $property;\n}</code></pre> <p>If you use the Bundle version of the AutoMapper, there is also additional functions available.</p> <p>Note</p> <p>In standalone mode we do not provide any functions to the expression language. However we are interested in adding some functions to the expression language in the future. If you have some use cases that you would like to see covered, please open an issue on the GitHub repository.</p>"},{"location":"mapping/conditional-mapping/#php-function","title":"PHP function","text":"<p>You can use a php function to define the condition. This function must return a boolean value.</p> <pre><code>class Source\n{\n    #[MapTo(if: 'boolval')]\n    public string $property = '';\n}</code></pre> <p>Warning</p> <p>If the PHP function need more arguments than the <code>source</code> object and the <code>context</code> array, it will throw an exception.</p>"},{"location":"mapping/conditional-mapping/#static-callback","title":"Static callback","text":"<p>You can use a static callback to define the condition.</p> <pre><code>class Source\n{\n    public bool $propertyIsValid = true;\n\n    #[MapTo(if: [self::class, 'isPropertyValid'])]\n    public $property;\n\n    public static function isPropertyValid(Source $source, array $context): bool\n    {\n        return $source-&gt;propertyIsValid &amp;&amp; ($context['custom_key'] ?? false) === true;\n    }\n}</code></pre> <p>The static callback can accept the <code>source</code> object and the <code>context</code> array as arguments.</p>"},{"location":"mapping/conditional-mapping/#dynamic-callback","title":"Dynamic callback","text":"<p>You can also reference a method of the object declaring the attribute to define the condition.</p> <pre><code>class Source\n{\n    public bool $propertyIsValid = true;\n\n    #[MapTo(if: 'isPropertyValid')]\n    public $property;\n\n    public function isPropertyValid(): bool\n    {\n        return $this-&gt;propertyIsValid;\n    }\n}</code></pre> <p>The dynamic callback can accept the <code>source</code> object and the <code>context</code> array as arguments.</p>"},{"location":"mapping/date-time/","title":"DateTime format","text":"<p>There is multiple ways to tell the AutoMapper which DateTime format to use. All theses have their own advantages and  act differently. Here is a hierarchy of each way to set this format:</p> <ul> <li>AutoMapper context;</li> <li>Property attribute;</li> <li>Mapper attribute;</li> <li>Symfony Bundle configuration.</li> </ul> <p>Considering this order, if you set a format in a Mapper attribute and in a property attribute, we will use the  property attribute format because it is a higher priority.</p>"},{"location":"mapping/date-time/#automapper-context","title":"AutoMapper context","text":"<p>To force a DateTime format everywhere you can use the AutoMapper context with the <code>MapperContext::DATETIME_FORMAT</code>:</p> <pre><code>use AutoMapper\\MapperContext;\n\n$source = new Source();\n$target = $autoMapper-&gt;map($source, 'array', [MapperContext::DATETIME_FORMAT =&gt; \\DateTimeInterface::ATOM]);</code></pre> <p>Note</p> <p>Be aware that by using AutoMapper context, any <code>#[MapTo]</code>, <code>#[MapFrom]</code>, <code>#[Mapper]</code> attribute or bundle configuration  will be ignored.</p>"},{"location":"mapping/date-time/#property-attribute","title":"Property attribute","text":"<p>To set a DateTime format onto a <code>#[MapTo]</code> attribute (this will be the same for <code>#[MapFrom]</code> attribute), you'll have  to do as following:</p> <pre><code>class Source\n{\n    #[MapTo(dateTimeFormat: \\DateTimeInterface::ATOM)]\n    public \\DateTimeImmutable $dateTime;\n}</code></pre> <p>Note</p> <p>If you have a <code>#[Mapper]</code> attribute onto the same class with a DateTime format set or a Bundle configuration set, it  will be ignored and the property attribute configuration will be used.</p>"},{"location":"mapping/date-time/#mapper-attribute","title":"Mapper attribute","text":"<p>To set a DateTime format onto a <code>#[Mapper]</code> attribute, you'll have to do as following:</p> <pre><code>#[Mapper(dateTimeFormat: \\DateTimeInterface::ATOM)]\nclass Source\n{\n    public \\DateTimeImmutable $dateTime;\n}</code></pre> <p>Note</p> <p>If you have a bundle configuration it will be ignored and the mapper attribute will be used.</p>"},{"location":"mapping/date-time/#symfony-bundle-configuration","title":"Symfony Bundle configuration","text":"<pre><code>automapper:\n  date_time_format: !php/const:DateTimeInterface::ATOM</code></pre> <p>Note</p> <p>If you use an attribute DateTime format or the AutoMapper context, this configuration will be ignored.</p>"},{"location":"mapping/groups/","title":"Groups","text":"<p>In addition to use the Symfony Serializer <code>#[Groups]</code> attribute, you can also use the <code>#[MapTo]</code> and <code>#[MapFrom]</code>  attributes to define groups of properties that should be mapped.</p> <pre><code>class Source\n{\n    #[MapTo(target: 'array', groups: ['group1', 'group2'])]\n    public $groupedProperty;\n}</code></pre> <p>When doing so the property will be mapped only if the context contains at least one group defined in the <code>groups</code> argument.</p>"},{"location":"mapping/groups/#cumulative-groups","title":"Cumulative groups","text":"<p>When using both groups from the Symfony Serializer <code>#[Groups]</code> attribute and the <code>groups</code> argument from the <code>#[MapTo]</code>  or <code>#[MapFrom]</code> attributes, the latter groups will override the former groups.</p> <pre><code>use Symfony\\Component\\Serializer\\Attribute\\Groups;\n\nclass Source\n{\n    #[Groups(['group1', 'group2'])]\n    #[MapTo(target: 'array', groups: ['group3'])]\n    public $groupedProperty;\n}</code></pre> <p>In this case the property will be mapped only if the context contains the <code>group3</code> group.</p>"},{"location":"mapping/ignoring-properties/","title":"Ignoring properties","text":"<p>Sometimes you may want to ignore a property during the mapping process. This can be done using the <code>#[MapTo]</code> or <code>#[MapFrom]</code> attributes with the <code>ignore</code> argument set to <code>true</code>.</p> <pre><code>class Source\n{\n    #[MapTo(target: SourceDTO::class, ignore: true)]\n    #[MapTo(target: 'array', ignore: false)]\n    public $ignoredProperty;\n}</code></pre> <p>Setting <code>ignore</code> to <code>false</code> may be useful when used in conjunction with the <code>#[Ignore]</code> attribute from the Symfony Serializer.</p> <pre><code>use Symfony\\Component\\Serializer\\Attribute\\Ignore;\n\nclass Source\n{\n    #[Ignore]\n    #[MapTo(target: SourceDTO::class, ignore: false)]\n    public $ignoredProperty;\n}</code></pre> <p>In this case the property will be mapped to the <code>SourceDTO</code> class, but will be ignored when using the Symfony Serializer.</p>"},{"location":"mapping/inheritance/","title":"Inheritance Mapping","text":"<p>A <code>source</code> or <code>target</code> class may inherit from another class. </p> <p>When creating the mapping, AutoMapper can determine the correct mapping by using the inheritance information from the Symfony Serializer <code>#[DiscriminatorMap]</code> attribute.</p> <pre><code>#[DiscriminatorMap(typeProperty: 'type', mapping: [\n    'cat' =&gt; Cat::class,\n    'dog' =&gt; Dog::class,\n    'fish' =&gt; Fish::class,\n])]\nabstract class Pet\n{\n    /** @var string */\n    public $type;\n\n    /** @var string */\n    public $name;\n\n    /** @var PetOwner */\n    public $owner;\n}</code></pre> <p>When mapping a <code>Pet</code> object, AutoMapper will automatically determine the correct class to instantiate based on the <code>type</code> property.</p> <p>Learn more about the Symfony Serializer inheritance mapping</p> <p>Note</p> <p>If you don't use the Symfony Serializer we do not provide, yet, any way to determine the correct class to instantiate.</p>"},{"location":"mapping/mapper-attribute/","title":"<code>#[Mapper]</code> attribute","text":"<p>The <code>#[Mapper]</code> attribute allow you to configure how a mapper should be generated specifically.</p> <pre><code>#[Mapper(constructorStrategy: ConstructorStrategy::NEVER)]\nclass Entity\n{\n    public string $foo;\n}</code></pre> <p>In this example when a mapper is targeting the <code>Entity</code> class, the constructor will never be used.</p>"},{"location":"mapping/mapper-attribute/#specify-a-source-or-target","title":"Specify a source or target","text":"<p>You can also limit the scope of the <code>#[Mapper]</code> attribute to a specific source or target.</p> <pre><code>#[Mapper(source: EntityDto::class, constructorStrategy: ConstructorStrategy::NEVER)]</code></pre>"},{"location":"mapping/mapper-attribute/#datetime-format","title":"DateTime format","text":"<p>You can override DateTime format for a whole class by using <code>#[Mapper]</code> attribute:</p> <pre><code>#[Mapper(dateTimeFormat: \\DateTimeInterface::ATOM)]</code></pre> <p>This way, all your class properties that are DateTime will be transformed to string with the corresponding format. For more details about how each DateTime format configuration works together please read the dedicated page: DateTime format.</p>"},{"location":"mapping/mapper-attribute/#priority","title":"Priority","text":"<p>If multiple <code>#[Mapper]</code> attributes are defined for the same mapping, the one with the highest priority will be used.</p> <pre><code>#[Mapper(source: EntityDto::class, constructorStrategy: ConstructorStrategy::NEVER, priority: 2)]\nclass Entity\n{\n    public string $foo;\n}\n\n#[Mapper(constructorStrategy: ConstructorStrategy::ALWAYS, priority: 1)]\nclass EntityDto\n{\n    public string $foo;\n}</code></pre> <p>In this example when a mapper is targeting the <code>Entity</code> class from the <code>EntityDto</code> class the constructor will never be used as the <code>Entity</code> mapper attribute has a higher priority.</p> <p>If priorities are the same, order is not guaranteed.</p>"},{"location":"mapping/provider/","title":"Provider","text":"<p>Warning</p> <p>Providers are experimental and may change in the future.</p> <p>Providers are a way to instantiate the <code>target</code> during the mapping process.</p> <p>By default, the AutoMapper will try to instantiate the <code>target</code> object using the constructor, or without if not possible. However, in some cases you may want to use a custom provider. Like fetch the object from the database, or use a factory.</p> <p>In this case you can create a provider class that implements the <code>ProviderInterface</code> interface.</p> <pre><code>use AutoMapper\\Provider\\ProviderInterface;\n\nclass MyProvider implements ProviderInterface\n{\n    public function provide(string $targetType, mixed $source, array $context): object|null\n    {\n        return new $targetType();\n    }\n}</code></pre> <p>You have to register this provider when you create the <code>AutoMapper</code> object.</p> <pre><code>use AutoMapper\\AutoMapper;\n\n$autoMapper = AutoMapper::create(providers: [new MyProvider()]);</code></pre> <p>Note</p> <p>When using the Symfony Bundle version of the AutoMapper, you can use the <code>automapper.provider</code> tag to register the provider. If you have autoconfiguration enabled, you do not need to register the provider manually as the tag will be automatically added.</p> <p>Then you can use the <code>#[MapProvider]</code> attribute on top of the <code>target</code> class that you want to use this provider.</p> <pre><code>use AutoMapper\\Attribute\\MapProvider;\n\n#[MapProvider(provider: MyProvider::class)]\nclass Entity\n{\n}</code></pre> <p>Note</p> <p>When using the Symfony Bundle version of the AutoMapper, the provider will be the service id, which may be different from the class name.</p> <p>Now, every time the <code>AutoMapper</code> needs to instantiate the <code>Entity</code> class, it will use the <code>MyProvider</code> class.</p> <p>If you provider return <code>null</code>, the <code>AutoMapper</code> will try to instantiate the <code>target</code> object using the constructor, or without if not possible.</p> <p>Note</p> <p>When using the <code>target_to_populate</code> option in the <code>context</code> array, the <code>AutoMapper</code> will use this object instead of the one created by the provider.</p>"},{"location":"mapping/provider/#early-return","title":"Early return","text":"<p>If you want to return the object from the provider without mapping the properties, you can return a  <code>AutoMapper\\Provider\\EarlyReturn</code> object from the <code>provide</code> method with the object you want to return inside.</p> <pre><code>use AutoMapper\\Provider\\EarlyReturn;\nuse AutoMapper\\Provider\\ProviderInterface;\n\nclass MyProvider implements ProviderInterface\n{\n    public function provide(string $targetType, mixed $source, array $context): object|null\n    {\n        return new EarlyReturn(new $targetType());\n    }\n}</code></pre>"},{"location":"mapping/serializer/","title":"Symfony Serializer Attributes","text":"<p>Symfony Serializer is a powerful component that can serialize and deserialize objects to and from various formats. It can use several attributes to customize the serialization process.</p> <p>When this component is available, AutoMapper can use these attributes to customize the mapping process.</p>"},{"location":"mapping/serializer/#groups","title":"<code>#[Groups]</code>","text":"<p>The Symfony Serializer <code>#[Groups]</code> attribute can be used to define groups of properties that should be mapped.</p> <pre><code>use Symfony\\Component\\Serializer\\Attribute\\Groups;\n\nclass Source\n{\n    #[Groups(['group1', 'group2'])]\n    public $groupedProperty;\n}</code></pre> <p>! [!WARNING] When both <code>target</code> and <code>source</code> objects have groups, the property will be mapped only if the context contains at least one group from the <code>target</code> object and one group from the <code>source</code> object.</p> <p>More information on the Groups attribute</p>"},{"location":"mapping/serializer/#ignore","title":"<code>#[Ignore]</code>","text":"<p>The Symfony Serializer <code>#[Ignore]</code> attribute can be used to ignore a property during the mapping process.</p> <pre><code>use Symfony\\Component\\Serializer\\Attribute\\Ignore;\n\nclass Source\n{\n    #[Ignore]\n    public $ignoredProperty;\n}</code></pre> <p>More information on the Ignore attribute</p>"},{"location":"mapping/serializer/#maxdepth","title":"<code>#[MaxDepth]</code>","text":"<p>The Symfony Serializer <code>#[MaxDepth]</code> attribute can be used to limit the depth of the serialization process.</p> <pre><code>use Symfony\\Component\\Serializer\\Attribute\\MaxDepth;\n\nclass Source\n{\n    #[MaxDepth(1)]\n    public  $nestedProperty;\n}</code></pre> <p>More information on the MaxDepth attribute</p>"},{"location":"mapping/serializer/#name-converters","title":"Name converters","text":"<p>AutoMapper can use the Symfony Serializer name converters to convert the property names, when mapping to  or from an array.</p> <pre><code>use Symfony\\Component\\Serializer\\NameConverter\\CamelCaseToSnakeCaseNameConverter;\n\n$autoMapper = AutoMapper::create(nameConverter: new CamelCaseToSnakeCaseNameConverter());</code></pre> <p>More information on the Name converters</p>"},{"location":"mapping/serializer/#normalizer-bridge","title":"Normalizer Bridge","text":"<p>Additionally, this library provide a normalizer which implements the <code>Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface</code> interface.</p> <p>It's goal is to be as close as possible to the <code>ObjectNormalizer</code> of the <code>symfony/serializer</code> component, but with a focus on performance.</p> <pre><code>use AutoMapper\\Normalizer\\AutoMapperNormalizer;\nuse Symfony\\Component\\Serializer\\Serializer;\n\n$autoMapper = AutoMapper::create();\n$serializer = new Serializer([new AutoMapperNormalizer($autoMapper)]);</code></pre>"},{"location":"mapping/transformer/","title":"Transformer","text":"<p>Transformers are the way the AutoMapper transforms the value from a <code>source</code> property to a <code>target</code> property.</p> <p>By default, it tries to find the best transformer given the type of the <code>source</code> and <code>target</code> properties.</p> <p>In some cases you may want to use a custom transformer. This can be done by using the <code>transformer</code> parameter of the <code>#[MapTo]</code> or <code>#[MapFrom]</code> attributes.</p> <p>Like the <code>if</code> argument, the <code>transformer</code> argument can accept several types of values.</p>"},{"location":"mapping/transformer/#expression-language","title":"Expression language","text":"<p>You can use the Symfony Expression Language to define the transformer. In this context the <code>source</code> object is available as <code>source</code> and the <code>context</code> array is available as <code>context</code>.</p> <pre><code>class Source\n{\n    #[MapTo(transformer: \"source.property === 'foo' ? 'bar' : 'baz'\")]\n    public string $property;\n}</code></pre> <p>If you use the Bundle version of the AutoMapper, there is also additional functions available.</p> <p>Note</p> <p>In standalone mode we do not provide any functions to the expression language. However we are interested in adding some functions to the expression language in the future. If you have some use cases that you would like to see covered, please open an issue on the GitHub repository.</p>"},{"location":"mapping/transformer/#using-a-callable","title":"Using a callable","text":"<pre><code>class Source\n{\n    #[MapTo(transformer: 'strtoupper')]\n    public string $property;\n}</code></pre> <p>In this case it will use the <code>strtoupper</code> PHP function to transform the value of the <code>property</code> property.</p>"},{"location":"mapping/transformer/#using-a-static-callback","title":"Using a static callback","text":"<pre><code>class Source\n{\n    #[MapTo(transformer: [self::class, 'transform'])]\n    public string $property;\n\n    public static function transform(string $value, Source $source, array $context): string\n    {\n        return strtoupper($value);\n    }\n}</code></pre> <p>The callback will receive, the value of the source property, the whole <code>source</code> object and the <code>context</code> array.</p>"},{"location":"mapping/transformer/#creating-a-custom-transformer","title":"Creating a custom transformer","text":"<p>Warning</p> <p>Custom transformers are experimental and may change in the future.</p> <p>You can also create a custom transformer by implementing the <code>PropertyTransformerInterface</code> interface. This can be useful if you need external dependencies or if you want to reuse the transformer in multiple places.</p> <pre><code>namespace App\\Transformer;\n\nuse AutoMapper\\Transformer\\PropertyTransformer\\PropertyTransformerInterface;\n\nclass UrlTransformer implements PropertyTransformerInterface\n{\n    public function __construct(private UrlGeneratorInterface $urlGenerator)\n    {\n    }\n\n    public function transform(mixed $value, object|array $source, array $context): mixed\n    {\n        return $this-&gt;urlGenerator-&gt;generate('my_route', ['id' =&gt; $value]);\n    }\n}</code></pre> <p>You will need to register the transformer in the <code>AutoMapper</code> instance.</p> <pre><code>use AutoMapper\\AutoMapper;\n\n$autoMapper = AutoMapper::create(propertyTransformers: [new UrlTransformer($urlGenerator)]);</code></pre> <p>Note</p> <p>When using the Symfony Bundle version of the AutoMapper, you can use the <code>automapper.property_transformer</code> tag to  register the transformer.</p> <p>If you have autoconfiguration enabled, you do not need to register the transformer manually as the tag will be  automatically added.</p> <p>Then you can use it in the <code>transformer</code> argument.</p> <pre><code>use App\\Transformer\\UrlTransformer;\n\nclass Source\n{\n    #[MapTo(property: 'url', transformer: UrlTransformer::class)]\n    public int $id;\n}</code></pre> <p>Note</p> <p>When using the Symfony Bundle version of the AutoMapper, the transformer will be the service id, which may be different from the class name.</p>"},{"location":"mapping/transformer/#automatically-apply-custom-transformers","title":"Automatically apply custom transformers","text":"<p>You may want to automatically apply a custom transformer given a specific condition. In order to do so, you can implement the <code>PropertyTransformerSupportInterface</code> interface.</p> <pre><code>namespace App\\Transformer;\n\nuse AutoMapper\\Metadata\\MapperMetadata;\nuse AutoMapper\\Metadata\\SourcePropertyMetadata;\nuse AutoMapper\\Metadata\\TargetPropertyMetadata;\nuse AutoMapper\\Metadata\\TypesMatching;\nuse AutoMapper\\Transformer\\PropertyTransformer\\PropertyTransformerInterface;\nuse AutoMapper\\Transformer\\PropertyTransformer\\PropertyTransformerSupportInterface;\n\nclass UrlTransformer implements PropertyTransformerInterface, PropertyTransformerSupportInterface\n{\n    public function __construct(private UrlGeneratorInterface $urlGenerator)\n    {\n    }\n\n    public function supports(TypesMatching $types, SourcePropertyMetadata $source, TargetPropertyMetadata $target, MapperMetadata $mapperMetadata): bool\n    {\n        $sourceUniqueType = $types-&gt;getSourceUniqueType();\n\n        if (null === $sourceUniqueType) {\n            return false;\n        }\n\n        return $sourceUniqueType-&gt;getBuiltinType() === 'int' &amp;&amp; $source-&gt;property === 'id' &amp;&amp; $target-&gt;property === 'url';\n    }\n\n    public function transform(mixed $value, object|array $source, array $context): mixed\n    {\n        return $this-&gt;urlGenerator-&gt;generate('my_route', ['id' =&gt; $value]);\n    }\n}</code></pre> <p>In this case every transformation where the source <code>id</code> property is an <code>int</code> and the target property is named <code>url</code>  will use the <code>UrlTransformer</code>. There is no need to specify the transformer in the <code>#[MapTo]</code> or <code>#[MapFrom]</code> attribute.</p>"},{"location":"mapping/transformer/#prioritize-transformers","title":"Prioritize transformers","text":"<p>If you have multiple transformers that can be applied to the same transformation, you can prioritize them by using the <code>PrioritizedPropertyTransformerInterface</code> interface.</p> <pre><code>namespace App\\Transformer;\n\nclass UrlTransformer implements PropertyTransformerInterface, PropertyTransformerSupportInterface, PrioritizedPropertyTransformerInterface\n{\n    // ...\n\n    public function getPriority(): int\n    {\n        return 10;\n    }\n}</code></pre> <p>When multiple transformers can be applied, the one with the highest priority will be used.</p>"}]}