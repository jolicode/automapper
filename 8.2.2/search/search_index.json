{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome \ud83d\udc4b","text":"<p>Welcome to the AutoMapper documentation, this library solves a simple problem: removing all the code you need to map one object to another. A boring code to write and often replaced by less-performant alternatives like Symfony's Serializer.</p> <p>AutoMapper uses a convention-based matching algorithm to match up source to destination values. AutoMapper is geared  towards model projection scenarios to flatten complex object models to DTOs and other simple objects, whose design is  better suited for serialization, communication, messaging, or simply an anti-corruption layer between the domain and  application layer.</p>"},{"location":"#quick-start","title":"Quick start \ud83d\ude80","text":""},{"location":"#what-is-the-automapper","title":"What is the AutoMapper ? \ud83e\udd14","text":"<p>The AutoMapper is a anything to anything mapper, you can make either arrays, objects or array of objects and output the  same. Mapping works by transforming an input object of one type into an output object of a different or same type (in  case of deep copy). What makes AutoMapper interesting is that it provides some interesting conventions to take the dirty  work out of figuring out how to map type A to type B and it has a strong aim on performance by generating the mappers  whenever you require it. As long as type B follows AutoMapper\u2019s established convention, almost zero configuration is  needed to map two types.</p>"},{"location":"#why-should-i-use-it","title":"Why should I use it ? \ud83d\ude4b","text":"<p>Mapping code is boring. And in PHP, you often replace that by using Symfony's Serializer because you don't want to do it by hand. We were doing the same but performance made it not possible anymore. The AutoMapper replaces the Serializer  to do the same output by generating PHP code so it's like your wrote the mappers yourself.</p> <p>The real question may be \u201cwhy use object-object mapping?\u201d Mapping can occur in many places in an application, but  mostly in the boundaries between layers, such as between the UI/Domain layers, or Service/Domain layers. Concerns of  one layer often conflict with concerns in another, so object-object mapping leads to segregated models, where concerns  for each layer can affect only types in that layer.</p>"},{"location":"#installation","title":"Installation \ud83d\udce6","text":"<pre><code>composer require jolicode/automapper</code></pre>"},{"location":"#how-to-use-it","title":"How to use it ? \ud83d\udd79\ufe0f","text":"<p>First, you need both a source and destination type to work with. The destination type\u2019s design can be influenced by the  layer in which it lives, but the AutoMapper works best as long as the names of the members match up to the source  type\u2019s members. If you have a source member called \"firstName\", this will automatically be mapped to a destination  member with the name \"firstName\".</p> <pre><code>class InputUser\n{\n  public function __construct(\n    public readonly string $firstName,\n    public readonly string $lastName,\n    public readonly int $age,\n  ) {\n  }\n}\n\nclass DatabaseUser\n{\n  public function __construct(\n    #[ORM\\Column]\n    public string $firstName,\n    #[ORM\\Column]\n    public string $lastName,\n    #[ORM\\Column]\n    public int $age,\n  ) {\n  }\n}\n\n$automapper = \\AutoMapper\\AutoMapper::create();\ndump($automapper-&gt;map(new InputUser('John', 'Doe', 28), DatabaseUser::class));\n\n// ^ DatabaseUser^ {#1383\n//   +firstName: \"John\"\n//   +lastName: \"Doe\"\n//   +age: 28\n// }</code></pre>"},{"location":"#how-to-customize-the-mapping","title":"How to customize the mapping? \ud83d\ude80","text":"<p>The mapping process could be extended in multiple ways.</p>"},{"location":"#map-manually-a-single-property","title":"Map manually a single property","text":"<p>You can override the mapping of a single property by leveraging <code>AutoMapper\\Transformer\\CustomTransformer\\CustomPropertyTransformerInterface</code>. It can be useful if you need to map several properties from the source to a unique property in the target. </p> <pre><code>class BirthDateUserTransformer implements CustomPropertyTransformerInterface\n{\n    public function supports(string $source, string $target, string $propertyName): bool\n    {\n        return $source === InputUser::class &amp;&amp; $target === DatabaseUser::class &amp;&amp; $propertyName === 'birthDate';\n    }\n\n    /**\n     * @param InputUser $source\n     */\n    public function transform(object $source): \\DateTimeImmutable\n    {\n        return new \\DateTimeImmutable(\"{$source-&gt;birthYear}-{$source-&gt;birthMonth}-{$source-&gt;birthDay}\");\n    }\n}</code></pre>"},{"location":"#map-manually-a-whole-object","title":"Map manually a whole object","text":"<p>In order to customize the mapping of a whole object, you can leverage <code>AutoMapper\\Transformer\\CustomTransformer\\CustomModelTransformerInterface</code>. You have then full control over the transformation between two types:</p> <pre><code>use Symfony\\Component\\PropertyInfo\\Type;\n\nclass InputUserToDatabaseUserCustomTransformer implements CustomModelTransformerInterface\n{\n    public function supports(array $sourceTypes, array $targetTypes): bool\n    {\n        return $this-&gt;hasType($sourceTypes, DatabaseUser::class) &amp;&amp; $this-&gt;hasType($targetTypes, OutputUser::class);\n    }\n\n    /**\n     * @param DatabaseUser $source\n     */\n    public function transform(object $source): OutputUser\n    {\n        return OutputUser::fromDatabaserUser($source);\n    }\n\n    /**\n     * @param Type[] $types\n     * @param class-string $class\n     */\n    private function hasType(array $types, string $class): bool\n    {\n        foreach ($types as $type) {\n            if ($type-&gt;getClassName() === $class) {\n                return true;\n            }\n        }\n\n        return false;\n    }      \n}</code></pre>"},{"location":"_nav/","title":"nav","text":"<ul> <li>Quick start</li> <li>With Symfony</li> <li>Contributing</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#releasing","title":"Releasing","text":"<p>Whenever you're doing a release you need to do some updates in order for the project to keep history on what was done and some other stuff.</p>"},{"location":"contributing/#changelog","title":"Changelog","text":"<p>First you'll need to update the CHANGELOG file (<code>./CHANGELOG.md</code>), take everything under the <code>Unreleased</code> section and create a new section for your new tag with the today's date.</p>"},{"location":"contributing/#version","title":"Version","text":"<p>When a new version is tagged, you have to update the version constants within the <code>AutoMapper/AutoMapper</code> so  transformers can be updated with last AutoMapper version.</p>"},{"location":"symfony/","title":"Symfony","text":"<p>To make Symfony's users life easier, we made a bundle that will make all DependencyInjection for you.</p>"},{"location":"symfony/#quick-start","title":"Quick start \ud83d\ude80","text":""},{"location":"symfony/#installation","title":"Installation \ud83d\udce6","text":"<pre><code>composer require jolicode/automapper-bundle</code></pre>"},{"location":"symfony/#configuration","title":"Configuration \ud83d\udd27","text":"<p>To use it, you just have to add the main bundle class to your <code>config/bundles.php</code> file. <pre><code>return [\n    // ...\n    AutoMapper\\Bundle\\AutoMapperBundle::class =&gt; ['all' =&gt; true],\n];</code></pre></p> <p>Then configure the bundle to your needs, for example: <pre><code>automapper:\n  autoregister: true\n  mappings:\n    - source: AutoMapper\\Bundle\\Tests\\Fixtures\\User\n      target: AutoMapper\\Bundle\\Tests\\Fixtures\\UserDTO\n      pass: DummyApp\\UserConfigurationPass</code></pre></p> <p>Possible properties: - <code>normalizer</code> (default: <code>false</code>):  A boolean which indicate if we inject the AutoMapperNormalizer; - <code>cache_dir</code> (default: <code>%kernel.cache_dir%/automapper</code>): This setting allows you to customize the output directory  for generated mappers; - <code>mappings</code>: This option allows you to customize Mapper metadata, you have to specify <code>source</code> &amp; <code>target</code> data types  and related configuration using <code>pass</code> field. This configuration should implements <code>AutoMapper\\Bundle\\Configuration\\MapperConfigurationInterface</code>. - <code>allow_readonly_target_to_populate</code> (default: <code>false</code>): Will throw an exception if you use a readonly class as target  to populate if set to <code>false</code>.</p>"},{"location":"symfony/#mapperconfigurationinterface","title":"MapperConfigurationInterface","text":"<p>You can add some metadata to customize a transformation. Here is an example:</p> <pre><code>class UserMapperConfiguration implements MapperConfigurationInterface\n{\n    public function getSource(): string\n    {\n        return User::class;\n    }\n\n    public function getTarget(): string\n    {\n        return UserDTO::class;\n    }\n\n    public function process(MapperGeneratorMetadataInterface $metadata): void\n    {\n        $metadata-&gt;forMember('yearOfBirth', function (User $user) {\n            return ((int) date('Y')) - ((int) $user-&gt;age);\n            return ((int) date('Y')) - ((int) $user-&gt;age);\n        });\n    }\n}</code></pre> <p>Here you have to inherit the <code>MapperConfigurationInterface</code> interface, that ways it will autoconfigure your  transformation for a given source &amp; target. And in the <code>process</code> method you will add or overwrite fields to map. The fields you give onto the <code>forMember</code> method are target fields and the callback will always give you the source  object.</p>"},{"location":"symfony/#normalizer-bridge","title":"Normalizer Bridge \ud83c\udf01","text":"<p>A Normalizer Bridge is available, aiming to be 100% feature compatible with the ObjectNormalizer of the  <code>symfony/serializer</code> component. The goal of this bridge is not to replace the ObjectNormalizer but rather  providing a very fast alternative.</p> <p>As shown in the benchmark above, using this bridge leads up to more than 8x speed increase in normalization.</p>"}]}